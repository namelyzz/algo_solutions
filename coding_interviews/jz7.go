package coding_interviews

/*
JZ7 重建二叉树

给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。
例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。

提示:
1.vin.length == pre.length
2.pre 和 vin 均无重复元素
3.vin出现的元素均出现在 pre里
4.只需要返回根结点，系统会自动输出整颗树做答案对比
*/

/*
思路：
二叉树的前序遍历和中序遍历的特性：
前序遍历：根节点 -> 左子树 -> 右子树
中序遍历：左子树 -> 根节点 -> 右子树

因此，对于给定的前序遍历序列，第一个元素一定是根节点
然后，在中序遍历序列中找到这个根节点，根节点左边就是左子树的中序遍历序列，右边就是右子树的中序遍历序列
同时，我们也可以根据左子树的节点数量（从中序遍历序列中得到）来将前序遍历序列分为根节点、左子树的前序遍历序列和右子树的前序遍历序列
上面这三步思路，应该很容易想到，我们可以根据前序和中序，很快找到根节点，左子树和右子树
所以，按着这个思路又可以递归的构建左子树和右子树

具体步骤可以具象化为：
1. 从前序遍历序列中取第一个元素，作为根节点。
2. 在中序遍历序列中找到根节点的位置，记为idx。那么：
	- 左子树的中序遍历序列为原中序遍历序列中从开始到idx-1的部分。
	- 右子树的中序遍历序列为原中序遍历序列中从idx+1到末尾的部分。
3. 根据左子树的节点数量（即idx - 中序遍历序列起始位置），我们可以在前序遍历序列中确定：
	- 左子树的前序遍历序列为原前序遍历序列中从第一个元素（根节点）之后到左子树节点数量为止的部分。
	- 右子树的前序遍历序列为原前序遍历序列中剩下的部分。

关键点1：我们需要在中序遍历序列中快速找到某个节点，这种需要定位的需求，适合用哈希表存储起来 val 和 idx 的映射关系

现在，我们需要构建递归函数。先明白一点，递归函数的目的是什么？
- 已知前序序列提供根节点信息，中序序列提供左右子树划分信息，我们要根据前序和中序遍历序列重建二叉树，这是一个分治问题
那么，我们需要哪些参数？
- 我们需要前序遍历序列和中序遍历序列，因为我们要找到其中的左右子树序列，但为了避免频繁传递数组，我们传递数组的索引范围
	- 前序遍历序列的当前范围：[preL, preR) 左闭右开
	- 中序遍历序列的当前范围：[inL, inR) 左闭右开
那么，我们需要返回什么？
- 每个递归调用需要构建当前子树并返回其根节点
- 上层递归需要这个根节点来构建更大的树

关键点2：上面3个问题，帮我们设计出递归函数参数和返回值：func(preL, preR, inL, inR int) *TreeNode，具体参数含义如下：
- preL: 当前子树在前序遍历序列中的起始索引（包含）
- preR: 当前子树在前序遍历序列中的结束索引（不包含）
- inL: 当前子树在中序遍历序列中的起始索引（包含）
- inR: 当前子树在中序遍历序列中的结束索引（不包含）

思路一步步清晰了，最后我们只需要写出递归体代码，就能重建二叉树了
递归终止条件：当当前范围为空时，即 preL == preR（因为左闭右开，区间内没有元素），返回 nil。
递归过程：
- 前序遍历的第一个元素 preOrder[preL] 是当前子树的根节点。
- 在中序遍历中找到根节点的位置，以此将中序遍历分为左子树和右子树。
- 计算左子树的节点个数，从而在前序遍历中确定左子树和右子树的范围。
- 递归构建左子树和右子树。

关键点3：怎么计算左子树的节点个数呢？
cnt := idxMp[preOrder[preL]] - inL 这个公式计算的是左子树的节点数量。
- preOrder[preL] 当前子树的根节点值
- idxMp[preOrder[preL]] 根节点在中序遍历序列中的索引位置
- inL 当前子树在中序序列中的起始位置
中序序列: [左子树节点..., 根节点, 右子树节点...]
          ↑              ↑
         inL        idxMp[preOrder[preL]]
所以 左子树节点数 = 根节点位置 - 中序序列起始位置

关键点4：递归体构建左右子树的边界条件非常容易混乱
每个递归调用都在处理一个完整的子树，边界参数定义了：
- 这个子树在前序序列中的范围
- 这个子树在中序序列中的范围
-----
左子树递归：
前序左边界：preL+1 （跳过根节点）
前序右边界：preL+1 + cnt （因为左子树有cnt个节点，所以从preL+1开始数cnt个）
中序左边界：inL （中序序列的当前起始）
中序右边界：inL + cnt （中序序列中从inL开始数cnt个，因为左子树有cnt个节点）
-----
右子树递归：
前序左边界：preL+1+cnt （左子树结束的下一个位置）
前序右边界：preR （当前前序序列的结束）
中序左边界：inL+cnt+1 （中序序列中左子树结束的下一个位置，也就是根节点的下一个位置）
中序右边界：inR （当前中序序列的结束）
*/

func reConstructBinaryTree(preOrder []int, inOrder []int) *TreeNode {
    n := len(preOrder)
    idxMp := make(map[int]int, n)
    for i, v := range inOrder {
        idxMp[v] = i
    }

    var dfs func(int, int, int, int) *TreeNode
    dfs = func(preL, preR, inL, inR int) *TreeNode {
        if preL == preR {
            return nil
        }

        cnt := idxMp[preOrder[preL]] - inL

        return &TreeNode{
            Val:   preOrder[preL],
            Left:  dfs(preL+1, preL+1+cnt, inL, inL+cnt),
            Right: dfs(preL+1+cnt, preR, inL+cnt+1, inR),
        }
    }
    return dfs(0, n, 0, n)
}
