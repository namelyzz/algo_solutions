package two_pointer

import "slices"

/*
思路：这是一个经典的 三数之和 问题，基于排序和双指针技巧来解决问题

首先是排序，排序的目的是将数组从小到大排列，这样我们可以通过双指针技巧来高效地找到三元组。
如果你能意识到，排序后，对于每一个 nums[i]，如果 nums[i] > 0，那么后面的元素肯定大于零，因此不可能有三数和为 0 的情况。
这样你就有了初步的优化思路了，我们后续再提如何进行优化

排序数组后，我们需要循环遍历找到符合题意的三元组
外层循环： for i := 0; i < n-2; i++
外层循环的目的是遍历每个可能的第一个数 nums[i]。我们需要至少有两个数 j 和 k 来组成三元组，所以循环结束条件是 i < n-2。

内存循环：三指针核心部分：
我们使用两个指针 j 和 k 来在当前数 nums[i] 之后的子数组中查找匹配的数字。
j 从 i+1 开始，指向当前数后面的位置。
k 从数组的末尾开始，指向最后一个数。
【关于 j 和 k 选取的位置，详见下文的 Tips1】
与 i 构成了三指针，进行三数之和的计算，sum := nums[i] + nums[j] + nums[k]
- 如果 sum == target，则找到了一个三元组 (nums[i], nums[j], nums[k])，我们将其加入结果中。
- 如果 sum < target，说明需要增大和，可以将 j 向右移动（即 j++）。
- 如果 sum > target，说明需要减小和，可以将 k 向左移动（即 k--）。

注意原题要求：答案中不可以包含重复的三元组。
这就需要去重，我们排过序，因此重复的数都是相邻的，跳过重复数比较简单
【j 和 k 的去重逻辑好理解，i 的去重有个易错点，我们在 Tips2 里详解】

回到开头我们提到了优化，我们意识到排序后 如果 nums[i] > target（即0），那么后面的元素都不用看了
再进一步仔细思考一下，在排序后的数组中，假设我们当前选定的元素是 nums[i]。我们知道，在有序数组中，后面的数都会更大。
如果接下来最小的两个元素（即 nums[i+1] 和 nums[i+2]）和 nums[i] 加起来的和已经大于 target（这里是 0），
那后续的和不可能再变小，肯定无法满足 nums[i] + nums[j] + nums[k] == 0 的条件。
因此得到剪枝条件1（注：最小值都已经大于 target 了，之后不可能有小于 target 的三元组了，直接 break）：

	if nums[i] + nums[i+1] + nums[i+2] > target {
	    break
	}

能想到最小值已经大于 target 场景，那么其对立面，有没有最大值都小于 target 的场景呢？
如果当前 i 的数加上数组中最大的两个数的和都小于 target，
就说明 无论 j 和 k 怎么选择，三数之和也不可能达到 target。
因此，可以得到剪枝条件2（注：这个最大值基于当前 i 构成，后续 i 会变大，因此用 continue 让 i 增大继续查找三元组）：

	if nums[i] + nums[n-2] + nums[n-1] < target {
	    continue
	}
*/
func threeSum(nums []int) [][]int {
    slices.Sort(nums)

    var res [][]int
    target, n := 0, len(nums)
    for i := 0; i < n-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }

        if nums[i]+nums[i+1]+nums[i+2] > target {
            break
        }
        if nums[i]+nums[n-2]+nums[n-1] < target {
            continue
        }

        j, k := i+1, n-1
        for j < k {
            sum := nums[i] + nums[j] + nums[k]
            if sum == target {
                res = append(res, []int{nums[i], nums[j], nums[k]})
                for j++; j < k && nums[j-1] == nums[j]; j++ {
                }
                for k--; k > j && nums[k] == nums[k+1]; k-- {
                }
            } else if sum < target {
                j++
            } else {
                k--
            }
        }
    }
    return res
}

/*
Tips1: j 和 k 位置选择
三指针甚至多指针的时候，对于其余指针，可能会有疑惑，
为什么 j 和 k 不能紧邻在 i 之后？
为什么 j 和 k 不能是最后两个元素？
双指针技巧的基本思想是：
    在 有序数组 中，我们可以用两个指针从不同的方向向中间逼近，
    逐步缩小范围，并通过对比这两个指针所指向的元素来做出决策。这样能够大大减少遍历的次数。
所以，如果没有这种“一头一尾”的布局，你就无法确定下一步该移动哪个指针，算法就会退化成暴力解法。
我们简化问题，当我们固定了第一个数 nums[i] 后，问题就变成：
    在剩下的区间 [i+1, n-1] 中找到两个数，使得它们的和等于 target - nums[i]。
因为我们已经排好序，数组是具有单调性的，现在让我们想想，为什么要在两端设置指针
因为这种布局，形成了“夹逼”势态，设当前三数之和为 sum = nums[i] + nums[j] + nums[k]。
情况 A：sum < target（和太小了）
我们需要让和变大。因为 k 已经在最右边（最大的位置），无法通过移动 k 来让和变得更大了。
唯一的选择：只能移动 j 向右（j++），去找一个大一点的数。决策明确，无需犹豫。
情况 B：sum > target（和太大了）
我们需要让和变小。因为 j 已经在最左边（最小的位置），无法通过移动 j 来让和变得更小了。
唯一的选择：只能移动 k 向左（k--），去找一个小一点的数。决策明确，无需犹豫。
结论：正是因为一头一尾，我们才能根据 sum 和 target 的大小关系，唯一确定指针移动的方向。
这使得我们在遍历 j 和 k 时，每个元素最多只被访问一次，复杂度是 O(N)。

说了正例，我们看看反例来加深理解，如果 j 和 k 都紧邻在 i 之后
初始状态：j 和 k 都在最小端，sum 肯定是当前可能的最小值。
如果不匹配：假设 sum < target（和太小），你需要变大。你是应该把 k 往右移？还是应该把 j 往右移？抑或是k 往右移 5 格，同时 j 往右移 2 格？
这里，你失去了方向感。因为 j 往右会让和变大，k 往右也会让和变大。你不知道哪种组合才是对的。为了不漏掉答案，你不得不尝试所有组合
变成了嵌套循环，寻找另外两个数的过程变成了 O(N^2)。加上最外层 i 的循环，总复杂度变成 O(N^3)

为什么不能 j 和 k 都选择数组末尾？同理，这样变成了当前区间最大的和
我们一样不知道应该怎么移动 j 和 k，并且同样退化到 O(N^3) 的暴力解法
*/

/*
Tips2：i 的去重逻辑
这里记录我第一次错误的原因，我当时想到的是：
i 在开头，我们先一直剔除重复值，但是 [0, 0, 0] 这个用例让我发现错误，针对 i 我先剔除重复值，那就没有值给我构成三元组了
i 的去重逻辑确实和 j、k 不太一样。简单来说，i 的去重核心在于：
    对于同一个数值，我们只允许它做一次“带头大哥”（三元组的第一个数）。
比如例子 nums = [-1, -1, 2]，目标是 0。
所以，我们只要 -1 已经做过一次“老大”并搜索完所有可能性了，后面的 -1 就不要再出来带队了
而不是先否定 -1 当“老大”的资格，所以代码逻辑应该是：
    如果我（当前数）跟我的前任（上一个数）一样，那我就不干了
因此，应该是 nums[i] == nums[i-1]，注意到这里 i-1，我们得加上 i > 0 的限制，来保持不越界
*/
