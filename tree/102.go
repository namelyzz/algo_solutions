package tree

/*
层级遍历是很多树 BFS 题目的基础，这种题目，我们都是可以使用广度优先搜索（BFS）进行层序遍历
首先，可以想到使用一个队列来存储当前层的所有节点，然后每次处理一层。

思路：
 1. 边界：如果根节点为空，直接返回空结果。
 2. 初始化队列，将根节点加入队列。
 3. 当队列不为空时，进行循环：
    a. 记录当前层的节点数量（即当前队列的长度）。
    b. 创建一个临时切片用于存储下一层的节点，以及一个切片用于存储当前层的节点值。
    c. 遍历当前层的每个节点：
    - 将节点值加入当前层值切片。
    - 如果节点有左子节点，加入临时切片（下一层）。
    - 如果节点有右子节点，加入临时切片（下一层）。
    d. 将队列更新为临时切片（即下一层的节点）。
    e. 将当前层值切片加入结果集。
 4. 返回结果集。
*/
func levelOrder(root *TreeNode) [][]int {
	// 边界情况：空树直接返回空数组
	if root == nil {
		return nil
	}

	// 初始化队列，将根节点加入队列开始遍历
	// 队列中存储的是待处理的节点
	queue := []*TreeNode{root}

	// 结果数组，每个元素代表一层的节点值
	var res [][]int

	// 外层循环：当队列不为空时，说明还有节点需要处理
	for len(queue) != 0 {
		// 记录当前层的节点数量
		n := len(queue)

		// 创建临时队列存储下一层的节点，预分配容量为当前层节点数的2倍（二叉树最多有两个子节点）
		tmp := make([]*TreeNode, 0, n*2)

		// 创建当前层的路径数组，存储当前层所有节点的值
		path := make([]int, 0, n)

		// 内层循环：处理当前层的所有节点
		for i := 0; i < n; i++ {
			// 从队列中取出当前节点（按加入顺序，即从左到右）
			cur := queue[i]

			// 将当前节点的值加入当前层路径
			path = append(path, cur.Val)

			// 将子节点加入队列，从左到右处理
			if cur.Left != nil {
				tmp = append(tmp, cur.Left)
			}
			if cur.Right != nil {
				tmp = append(tmp, cur.Right)
			}
		}

		// 更新队列：用下一层的节点替换当前队列
		queue = tmp
		res = append(res, path)
	}

	return res
}
