package two_pointer

/*
思路：滑动窗口（这道算是活动窗口最典型的题目）
通过维护一个 窗口 来遍历整个字符串，确保这个窗口中的所有字符都不重复
  - 窗口定义：我们可以使用两个指针 start 和 i 来表示窗口的左右边界。start 表示当前子串的起始位置，而 i 表示窗口的结束位置
  - 扩展方式：随着 i 的移动，我们不断地将字符加入窗口
  - 收缩方式：当发现当前字符 s[i] 已经在窗口内时（即重复了）
    我们需要将窗口的左边界 start 向右移动，直到去掉重复字符，保证窗口内的字符不重复。

从收缩方式中，我们可以考虑使用哈希表来快速查重，以便能够快速查找是否有重复字符。
*/
func lengthOfLongestSubstring(s string) int {
	start, n := 0, len(s)            // start 是滑动窗口的左边界，n 是字符串的长度
	var res int                      // res 用来记录最长无重复子串的长度
	mp := make(map[byte]struct{}, n) // 用哈希表记录窗口中出现过的字符

	for i := 0; i < n; i++ { // i 是滑动窗口的右边界（当前字符）
		c := s[i]                // 获取当前字符
		if _, ok := mp[c]; !ok { // 如果字符 c 不在哈希表中，说明它没有重复
			mp[c] = struct{}{} // 将当前字符加入哈希表
		} else { // 如果字符 c 已经在哈希表中，说明遇到了重复字符
			// 需要缩小窗口，直到移除重复字符
			for start < i { // 将左边界 start 向右移动，直到移除重复字符
				if s[start] == c { // 找到重复字符的位置
					start++ // 移动左边界到重复字符的下一个位置
					break   // 一旦找到了重复字符，退出循环
				}
				delete(mp, s[start]) // 移除左边界处的字符，继续移动左边界
				start++              // 左边界继续向右移动
			}
		}

		// 在 `循环的每次迭代` 结束时更新最大长度
		res = max(res, i-start+1)
	}
	return res // 返回最长无重复子串的长度
}
