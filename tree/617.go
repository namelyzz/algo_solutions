package tree

/*
思路：
看图示，不难看出，如果两个节点重叠，那么将他们的值相加作为合并后节点的新值；
否则，不为 null 的节点将直接作为新二叉树的节点。

树的题目本身就适合用递归来做，这道题也不例外（为什么想到用递归？）
1. 二叉树具有天然的递归结构 - 每个节点都有左右子树
2. 合并操作在每棵子树上是相同的，符合递归的"自相似性"
3. 递归可以优雅地处理空节点情况

递归步骤思考
1. 基准情况分析：
  - 如果第一棵树为空，直接返回第二棵树（包括空的情况）
  - 如果第二棵树为空，直接返回第一棵树
  - 这样处理了所有空节点的情况

2. 合并过程
  - 在两棵树都不为空的情况下，将节点值相加
  - 递归合并左子树
  - 递归合并右子树
  - 将合并后的子树连接回当前节点

简而言之：
1. 如果其中一棵树为空，我们返回另一棵树作为合并的结果。
2. 如果两棵树都不为空，我们将两个节点的值相加，然后递归地合并左子树和右子树。
注意：我们以root1作为合并后的树，因此将合并后的左右子树赋值给root1的左右指针，然后返回root1。
如果我们希望不修改原树，我们可以创建新的节点。但是题目没有明确要求，我们可以根据需求选择。
*/
func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode {
	// 基准情况1：如果第一棵树为空，直接返回第二棵树
	// 这包括了第二棵树也为空的情况（返回nil）
	// 也包括第二棵树不为空的情况（直接使用第二棵树的节点）
	if root1 == nil {
		return root2
	}

	// 基准情况2：如果第二棵树为空，直接返回第一棵树
	// 此时第一棵树肯定不为空（否则会被上一条判断捕获）
	if root2 == nil {
		return root1
	}

	// 两棵树当前节点都不为空，将节点值相加
	// 我们选择修改root1作为合并后的节点，节省空间
	root1.Val += root2.Val

	// 递归左右子树
	left := mergeTrees(root1.Left, root2.Left)
	right := mergeTrees(root1.Right, root2.Right)

	// 将合并后的左右子树连接到当前节点，返回合并后的以 root1 为根的树
	root1.Left = left
	root1.Right = right
	return root1
}
