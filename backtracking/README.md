# 回溯算法题集

## 子集型回溯
### 子集型回溯的基本思路
本质是：从一个集合中，按照一定规则选择若干元素，组成满足条件的 “子集” 或 “组合”，需要枚举所有可能的有效解。

题目 `17`/`78`/`93`/`131`/`306`/`784` 为子集型回溯题目

这种题目的核心思路：
通过「递归 + 回溯」的方式，从集合的第一个元素开始：
1. 逐个判断 “选或不选” 当前元素，或
2. “选哪个元素” 

过程中逐步构建子集，最终收集所有有效解。

### 比较通用的模板：
```go
res = []  // 结果集，记录最终结果
path = [] // 记录状态，当前正在构建的子集/组合

// 递归函数
func dfs(条件1, 条件2, ...) {
    if 满足终止条件 {
        将 path 加入 res
    }
    
    // 选择逻辑：从某个索引开始，一般都是起始选择的索引，开始遍历
    for i := start; i < len(n); i++ {
        if 不满足条件 {
            continue 或者 break    
        }
        
        // 如果有选择，这里不选，将当前元素延长到下一个子问题
        dfs(条件1, 条件2, ...) // 伴随着 start + 1 之类的索引后移
        
        // 选择
        path = append(path, n[i])
        dfs(条件1, 条件2, ...) // 伴随着 start + 1 之类的索引后移
        path = path[:len(path)-1] // 回溯：移除当前元素，恢复路径，尝试其他选择
    }
}
```

### 小技巧和解题细节
1. 分析递归需要什么条件
   - 有时候，只需要知道当前索引即可，这是比较简单的情况
   - 但是，要分析我们是否需要选择一段子串，这时候可能需要 left/right 等两个条件来确定起始位置和终止位置等
   - 说到底，核心就是确保元素只能被选择一次，且按顺序选择，基于此出发，考虑递归函数需要什么条件
2. 终止条件：关于子集型回溯，通常可以分为如下的问题
    - 求子集：所有可能的子集都要收集（包括空集），因此每次进入递归都可以收集当前路径
    - 组合问题：比如需要固定的长度，终止条件还要考虑 `len(path) == k` 
    - 分割问题：终止条件一般是“已遍历完整个字符串”，一般还需要满足一些特定条件
3. 子集型回溯算法看模板可能很简单，但是难的往往是一些剪枝优化操作，要先考虑可能出现的各种非法情况，在递归路径上及时剪枝，减少无效的递归，常见的场景：
    - 无效元素：比如元素不在范围内，像复原 IP 地址中，当前段数值超过 255，直接跳过
    - 重复元素：比如要求不能有重复的子集，可能需要去重判断
    - 长度不符：如组合问题中，剩余元素不足以凑齐目标长度，直接终止
# 组合型回溯
组合型回溯实际上和子集型回溯差不了多少，其核心就是组合型回溯会有剪枝优化。

因为组合型题目往往会有一些条件，让你选出来需要的子集，因此，必然会有一些剪枝条件，来缩小搜索树的规模。

同样的，组合型也和子集型一样，有最终结果集和中间状态两个存储变量，也需要考虑回溯时恢复路径。

总体来说，组合型和子集型差别不大，剪枝条件一般也存在题目里，不要忽视剪枝即可。

题目包括：`77`/`216`/`22`/`39`/`40`/`93`，`93` 也是可以用组合型的思路去解题的